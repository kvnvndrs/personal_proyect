<div id="interactive-background" class="fixed inset-0 z-0 pointer-events-none">
  <canvas id="bg-canvas"></canvas>
</div>

<script>
  class ParticleNetwork {
    canvas: HTMLCanvasElement;
    ctx: CanvasRenderingContext2D;
    particles: Particle[];
    mouse: { x: number; y: number };
    width: number;
    height: number;

    constructor() {
      this.canvas = document.getElementById('bg-canvas') as HTMLCanvasElement;
      this.ctx = this.canvas.getContext('2d')!;
      this.particles = [];
      this.mouse = { x: -1000, y: -1000 };
      this.width = window.innerWidth;
      this.height = window.innerHeight;

      this.init();
      this.animate();
      this.addEventListeners();
    }

    init() {
      this.resize();
      this.createParticles();
    }

    resize() {
      this.width = window.innerWidth;
      this.height = window.innerHeight;
      this.canvas.width = this.width;
      this.canvas.height = this.height;
    }

    createParticles() {
      const particleCount = Math.min(Math.floor(this.width * this.height / 15000), 100);
      this.particles = [];
      for (let i = 0; i < particleCount; i++) {
        this.particles.push(new Particle(this.width, this.height));
      }
    }

    addEventListeners() {
      window.addEventListener('resize', () => {
        this.resize();
        this.createParticles();
      });

      window.addEventListener('mousemove', (e) => {
        this.mouse.x = e.clientX;
        this.mouse.y = e.clientY;
      });
    }

    animate() {
      this.ctx.clearRect(0, 0, this.width, this.height);
      
      this.particles.forEach(particle => {
        particle.update(this.width, this.height);
        particle.draw(this.ctx);
        this.connectParticles(particle);
      });

      this.connectMouse();
      requestAnimationFrame(this.animate.bind(this));
    }

    connectParticles(particle: Particle) {
      this.particles.forEach(otherParticle => {
        const dx = particle.x - otherParticle.x;
        const dy = particle.y - otherParticle.y;
        const distance = Math.sqrt(dx * dx + dy * dy);

        if (distance < 120) {
          this.ctx.beginPath();
          this.ctx.strokeStyle = `rgba(0, 243, 255, ${0.1 - distance / 1200})`;
          this.ctx.lineWidth = 1;
          this.ctx.moveTo(particle.x, particle.y);
          this.ctx.lineTo(otherParticle.x, otherParticle.y);
          this.ctx.stroke();
        }
      });
    }

    connectMouse() {
      this.particles.forEach(particle => {
        const dx = particle.x - this.mouse.x;
        const dy = particle.y - this.mouse.y;
        const distance = Math.sqrt(dx * dx + dy * dy);

        if (distance < 200) {
          this.ctx.beginPath();
          this.ctx.strokeStyle = `rgba(0, 255, 65, ${0.2 - distance / 2000})`; // Matrix Green connection
          this.ctx.lineWidth = 1.5;
          this.ctx.moveTo(particle.x, particle.y);
          this.ctx.lineTo(this.mouse.x, this.mouse.y);
          this.ctx.stroke();
        }
      });
    }
  }

  class Particle {
    x: number;
    y: number;
    vx: number;
    vy: number;
    size: number;

    constructor(width: number, height: number) {
      this.x = Math.random() * width;
      this.y = Math.random() * height;
      this.vx = (Math.random() - 0.5) * 0.5;
      this.vy = (Math.random() - 0.5) * 0.5;
      this.size = Math.random() * 2 + 1;
    }

    update(width: number, height: number) {
      this.x += this.vx;
      this.y += this.vy;

      if (this.x < 0 || this.x > width) this.vx *= -1;
      if (this.y < 0 || this.y > height) this.vy *= -1;
    }

    draw(ctx: CanvasRenderingContext2D) {
      ctx.beginPath();
      ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
      ctx.fillStyle = 'rgba(0, 243, 255, 0.3)'; // Cyber Blue
      ctx.fill();
    }
  }

  // Initialize only on client side
  if (typeof window !== 'undefined') {
    new ParticleNetwork();
  }
</script>

<style>
  canvas {
    display: block;
  }
</style>
